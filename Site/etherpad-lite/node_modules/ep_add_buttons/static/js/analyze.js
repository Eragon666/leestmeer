var _, $, jQuery;

var $ = require('ep_etherpad-lite/static/js/rjquery').$;
var _ = require('ep_etherpad-lite/static/js/underscore');
var colorsClass = 'colors';

/*
 * Red: 
 * Green: 
 * Blue: 
 * Orange: Average words
 */
var colors = ['black', 'red', 'green', 'blue', 'yellow', 'orange'];


/*
 * Init function
 */
function analyze(context) {
	this.ace = context.ace;
}


/*
 * Get the content from inside the text editor.
 * @param {function} callback
 */
function getPadContent(callback) {

	//Get the content frame
	var contentFrame = $('[name="ace_outer"]').contents().find('[name="ace_inner"]');

	var content = contentFrame.contents().children().find('body#innerdocbody');

	var data = [];
	var paragraph = '';

	//Get all content divjes
	content.children('div').each(function () {		
		//Remove HTML tags
		var content = $(this).html().replace(/<\/?[^>]+(>|$)/g, "");

		//If line is empty, new paragraph starts
		if (content === '') {

			//Only add to array if paragraph is not empty
			if (paragraph !== '') {
				data.push(paragraph);
				paragraph = '';
			}
		} else {
			paragraph = paragraph + content;
		}
	});

	callback(data);
}


/*
 * analyze the data from inside the pad
 * @param {string} type
 * @param {function} callback
 */
function analyzePadContent(type, callback) {

	getPadContent(function(data) {

		//countWords(data);
		//countSentences(data);

		sendParagraphs(data, type, function(analyzedData) {
			addScoreToSidebar(analyzedData);
			
			addHintsToSidebar(analyzedData);

			//Only update pad on the click of a button
			if (type === 'click') {
				updatePad(analyzedData);
			}

			countSentences(data);
		});

	});

}


/*
 * Send the paragraphs via the websocket to python
 * @param {object} data
 * @param {string} type
 * @param {function} callback
 */
function sendParagraphs(data, type, callback) {

	var message = {
		info: {
			id: pad.getPadId(),
			corpusSet: $('#dropdown').val(),
			type: type
		},
		overall: [{
			clibScore: 10,
			ciltScore: 20,
			analytics: {
				words: 500,
				paragraphs: data.length,
				avgSentence: '5',				
				totalWords: '5'
			}
		}],
		corpus: [{
			
		}],
		text: []
	};

	// Add all paragraphs to object
	for (var i in data) {
		var tmp = {
			paragraph: data[i],
			analytics: {
				words: 500,
				avgSentence: '5',
				totalWords: '5'
			},
			highlights: [
				{
					text: 'Welkom bij',
					color: '3'
				},
				{
					text: 'bij',
					color: '5'
				},
				{ 	
					text: 'leestmeer',
					color: '1'
				},
				{	
					text: 'tekst',
					color: '2'
				}
			],
			changed: true
		};

		message.text.push(tmp);

	}

	var text = sendAnalyzeRequest(message, callback);
}


/*
 * Get all the text from the editor and add it to a array
 * @param {object} content
 */
function getText(content) {
	var i = 0;
	var j = 0;
	var fullText = [];
	fullText[i] = [];

	content.children('div').each(function () {
		//Remove HTML tags
		var content = $(this).html().replace(/<\/?[^>]+(>|$)/g, "");

		//If line is empty, new paragraph starts
		if (content === '') {
			i++;
			j++;
			fullText[i] = [];
		} else {

			fullText[i][j] = content;
			j++;
		}
	});

	return fullText;
}


/*
 * Get the location of a search inside the text
 * @param {string} light
 * @param {array} array: one paragraph of the full text
 * @return {object}
 */
function getLocation(light, array, cb) {

	var search = light.text;
	

	//Loop through the array for each line
	for(var index in array) {
		//regex to find the word 
		//var startY = array[index].search('\s*?(' + search + ')[\\s.,?]');
		var startY = array[index].search(search);

		//If found
		if (startY > -1) {
			//Get endY, endY is startY + length of the search
			var endY = startY + search.length;
			
			cb(light.color, {startX: index, startY: startY, endX: index, endY: endY});
			//ace
			return;
		}
	}
	
	//If search not found
	cb(null);
}


function countWords(data) {

}

function countSentences(data) {


}