var _, $, jQuery;

var $ = require('ep_etherpad-lite/static/js/rjquery').$;
var _ = require('ep_etherpad-lite/static/js/underscore');
var colorsClass = 'colors';

/*
 * Red: 
 * Green: 
 * Blue: 
 * Orange: Average words
 */
var colors = ['black', 'red', 'green', 'blue', 'yellow', 'orange'];


/*
 * Init function
 */
function analyze(context) {
	this.ace = context.ace;
}


/*
 * Get the content from inside the text editor.
 * @param {function} callback
 */
function getPadContent(callback) {

	//Get the content frame
	var contentFrame = $('[name="ace_outer"]').contents().find('[name="ace_inner"]');

	var content = contentFrame.contents().children().find('body#innerdocbody');

	var data = [];
	var paragraph = '';

	//Get all content divjes
	content.children('div').each(function () {		
		//Remove HTML tags
		var content = $(this).html().replace(/<\/?[^>]+(>|$)/g, "");

		//If line is empty, new paragraph starts
		if (content === '') {

			//Only add to array if paragraph is not empty
			if (paragraph !== '') {
				data.push(paragraph);
				paragraph = '';
			}
		} else {
			paragraph = paragraph + content;
		}
	});

	callback(data);
}


/*
 * analyze the data from inside the pad
 * @param {string} type
 * @param {function} callback
 */
function analyzePadContent(type, callback) {

	getPadContent(function(data) {

		//countWords(data);
		//countSentences(data);

		sendParagraphs(data, type, function(analyzedData) {
			addScoreToSidebar(analyzedData);
			
			addHintsToSidebar(analyzedData);

			//Only update pad on the click of a button
			if (type === 'click') {
				updatePad(analyzedData);
			}

			countSentences(data);
		});

	});

}


/*
 * Send the paragraphs via the websocket to python
 * @param {object} data
 * @param {string} type
 * @param {function} callback
 */
function sendParagraphs(data, type, callback) {

	var message = {
		info: {
			id: pad.getPadId(),
			corpusSet: $('#dropdown').val(),
			type: type
		},
		overall: [{
			clibScore: 10,
			ciltScore: 20,
			analytics: {
				words: 500,
				paragraphs: data.length,
				avgSentence: '5',				
				totalWords: '5'
			}
		}],
		corpus: [{
			
		}],
		text: []
	};

	// Add all paragraphs to object
	for (var i in data) {
		var tmp = {
			paragraph: data[i],
			analytics: {
				words: 500,
				avgSentence: '5',
				totalWords: '5'
			},
			highlights: [
				{
					text: 'Welkom bij',
					color: '3'
				},
				{
					text: 'bij',
					color: '5'
				},
				{ 	
					text: 'leestmeer',
					color: '1'
				},
				{	
					text: 'tekst',
					color: '2'
				}
			],
			changed: true
		};

		message.text.push(tmp);

	}

	var text = sendAnalyzeRequest(message, callback);
}


/*
 * Add info to the sidebar
 * @param {oject} data
 */
function addScoreToSidebar(data) {

	var statistics = ['avi', 'clib', 'cilt'];

	//If the wrapper for the metrics already exists update the values, else update the scores.
	if ($('.metrics').length) {

		statistics.forEach(function(entry) {			
			var oldscore = $('.metrics-' + entry + 'score').html();
			var newscore = data.overall[0][entry + 'Score'];

			$('.metrics-' + entry + 'score').html(newscore);

			if (oldscore != newscore ) {

				$('.metrics-' + entry + 'score').toggleClass('metrics-score-update');

				setTimeout( function(){ 
					$('.metrics-' + entry + 'score').toggleClass('metrics-score-update');
				}  , 1000 );
			}
		});

	} else {

		var content = '<div class="metrics">' +
			'<table class="metrics-table">';

		statistics.forEach(function(entry) {
			content += '<tr class="metrics-row">' +
				'<td class="metrics-title metrics-' + entry + '">' + entry + '-Score</td>' +
				'<td class="metrics-score metrics-' + entry + 'score">' + data.overall[0][entry + 'Score'] + '</td>' +
				'</tr>';
		});

		content += '</table>' +
			'</div>';

		$('#sidebarInner').append(content);

	}
}


/*
 * Add hints to the sidebar
 * @param {object} data
 */
function addHintsToSidebar(data) {	
	var corpus = data.corpus;
	
	var config = {
		defaults: {
			headers: [
				{
					key: "high",
					title: "Dit moet worden gecorrigeerd!",
					color: "red"
				},
				{
					key: "medium",
					title: "Overweeg dit te corrigeren",
					color: "orange"
				},
				{
					key: "done",
					title: "Perfect!",
					color: "#38cc70"
				}
			]
		},		
		checks: [
			{
				name: "typeTokenFrequency",
				hint: "",
				message: {
					head: "Controleer de type token frequency",
					lower: "Is lager in de paragrafen %p%",
					higher: "Is hoger in de paragrafen %p%",
					equal: ""
				},
				warn: {
					check: 'times',
					lower: 2,
					higher: 2,
					equal: false
				},
				combine: true,
				importance: "medium",
				warnings: 0,
				paragraphs: {
					lower: [],
					higher: [],
					equal: []
				}
			},
			{
				name: "freqCommonWords",
				hint: "",
				message: {
					head: "Controleer het aantal veel voorkomende woorden in de tekst",
					lower: "Te weinig veel voorkomende woorden in %p%",
					higher: "Het aantal veel voorkomende woorden in %p% is relatief hoog",
					equal: ""
				},
				warn: {
					check: "sum",
					lower: 0.1,
					higher: 0.1,
					equal: false
				},
				combine: true,
				importance: "medium",
				warnings: 0,
				paragraphs: {
					lower: [],
					higher: [],
					equal: []
				}
			},
			{
				name: "avgLetters",
				hint: "",
				message: {
					head: "Controleer gemiddeld aantal letters per woord",
					lower: "De woorden in %p% zijn gemiddeld te kort",
					higher: "De woorden in %p% zijn gemiddeld te lang",
					equal: ""
				},
				warn: {
					check: "sum",
					lower: 1,
					higher: 1,
					equal: false
				},
				combine: true,
				importance: "high",
				warnings: 0,
				paragraphs: {
					lower: [],
					higher: [],
					equal: []
				}
			},
			{
				name: "avgWords",
				hint: "",
				message: {
					head: "Controleer gemiddeld aantal woorden",
					lower: "In de paragrafen %p% zijn er te weinig woorden",
					higher: "De volgende paragrafen bevatten te veel woorden: %p%",
					equal: ""
				},
				warn: {
					check: "sum",
					lower: 3,
					higher: 3,
					equal: false
				},
				combine: true,
				importance: "high",
				warnings: 0,
				paragraphs: {
					lower: [],
					higher: [],
					equal: []
				}
			}
		]
	};
	
	//c = current, cC = currentCheck, a = paragraph analytics, ca = corpus analytics
	var c, cC, a, ca;
	var par;
	
	ca = corpus[0];
	
	
	//For each paragraph check the analysis with the analysis of the corpus
	for (var i in data.text) {
		c = data.text[i];
		a = c.analytics;
		par = parseInt(i) + 1;
		
		for (var j in config.checks) {
			cC = config.checks[j];
			
			//check if it's lower/higher or equal, but only if the config says that
			//we need to check it.
			if (cC.warn.lower && a[cC.name] < ca[cC.name]) {
				//console.log(cC.name + ' is lower than the corpus in paragraph ' + i);
				cC.paragraphs.lower.push(par);
				cC.warnings++;
			} else if (cC.warn.higher && a[cC.name] > ca[cC.name]) {
				//console.log(cC.name + ' is higher than the corpus in paragraph ' + i);
				cC.paragraphs.higher.push(par);
				cC.warnings++;
			} else if (cC.warn.equal && a[cC.name] > ca[cC.name]) {
				//console.log(cC.name + ' is equal to the corpus in paragraph ' + i);
				cC.paragraphs.equal.push(par);
				cC.warnings++;
			}
		}
	}
	
	var text = "";
	
	if (!$('.feedback-wrap').length) {
		addFeedbackColumn(config);	
	}
	
	clearFeedback(config.defaults);	
	
	addFeedback(config.checks);
}


/*
 * Add the column for the feedback and initialize the accordeon effect
 * @param {object} config
 */
function addFeedbackColumn(config) {
	
	var content = '' + 
		'<div class="feedback-wrap">' +
			'<div class="feedback">Feedback</div>' +
			'<div class="accordion">' + 
				'<dl>';
	
	for (var i in config.defaults.headers) {
		var importance = config.defaults.headers[i];
		
		content = content +
					'<dt class="hide-' + importance.key + '">' +
						'<a href="#' + importance.key + '" aria-expanded="false" aria-controls="accordion1" class="accordion-title accordionTitle js-accordionTrigger" style="background-color:' + importance.color + '">' + 
							importance.title +
						'</a>' + 
					'</dt>' +
					'<dd class="accordion-content accordionItem is-collapsed hide-' + importance.key + '" id="' + importance.key + '" aria-hidden="true">' +
					'</dd>';
						
	}
	
	
	content = content + 
				'</dl>' + 
			'</div>' +
		'</div>';
	
	//Add the columns to the sidebar
	$('#sidebarInner').append(content);
	
	//Initialize the accordeon effect
	accordeon();
}


/*
 * Add the updated feedback to the already existing columns
 */
function addFeedback(checks) {
	var cC;
	var text = "";
	var template, par = "";
	
	//Now that we have compared the analytics we can convert the raw data to a more human
	//readable format!
	for (var k in checks) {
		cC = checks[k];
		
		if (cC.combine && cC.warnings > 0) {
			text += '<p><b>' + cC.message.head + '(' + cC.warnings + ')</b><br>';
			
			$.each(checks[k].paragraphs, function(index, value) {
				if (checks[k].warn[index] !== false && checks[k].paragraphs[index].length > 0) {
					//replace %p% in the template with the paragraphs
					par = checks[k].paragraphs[index].join([separator = ',']);
					template = checks[k].message[index];
					template = template.replace("%p%", par);
					text += template + '<br>';
				}
			}); 
			
			//If the text is filled, append it to the feedback column
			if (text !== '' && typeof text !== undefined) {
				text += '</p>';
				$('#' + checks[k].importance).append(text);
				$('.hide-' + checks[k].importance).show();
				text = '';
			} else {
				text = '<p>' + checks[k].message.head + '</p>';
				$('#done').append(text);
				$('.hide-done').show();
				text = '';
			}
		}
	}
}


/*
 * Clear the feedback
 * @param {object} config.defaults
 */
function clearFeedback(defaults) {
	
	for (var i in defaults.headers) {
		$('#' + defaults.headers[i].key).empty();
		$('.hide-' + defaults.headers[i].key).hide();
	}
	
}


/*
 * Update the pad with feedback from the server
 * @param {object} data
 */
function updatePad(data) {

	var fjq = $('[name="ace_outer"]').contents().find('[name="ace_inner"]')[0].contentWindow.$;


	//Get the content frame
	var contentFrame = $('[name="ace_outer"]').contents().find('[name="ace_inner"]');

	var content = contentFrame.contents().children().find('body#innerdocbody');

	colorPad(data, content, function(data, content) {
		addBrackets(data, content);
	});

}


/*
 * Add brackets to the pad to highlight paragraphs
 * @param {object} data
 * @param {object} content
 */
function addBrackets(data, content) {
	
	var children = content.children('div');
	var i = 0;
	var j = 0;
	var first = true;
	var last = false;
	var color = data.text[i].Colour;
	
	content.children('div').each(function () {		
		//Remove HTML tags
		var content = $(this).html().replace(/<\/?[^>]+(>|$)/g, "");

		//If line is empty, new paragraph starts
		if (content === '') {
			i++;
			first = true;
			if (data.text.hasOwnProperty(i)) {
				color = data.text[i].Colour;
			}
		} else {
			j++;
			var style = {};

			//Get the content of the next div and check if its empty
			var next = $(this).next().html().replace(/<\/?[^>]+(>|$)/g, "");

			if (next === '') {
				last = true;
			}

			//Always add border sides to the div
			$(this).addClass('fb-box fb-box-sides');

			//Add the top border if its the first div of the paragraph
			if (first) {
				first = false;

				/* 				$(this).addClass('fb-box-top'); */

			} else {
				$(this).addClass('fb-box-notoppadding');
			}

			//If this is the last div of the paragraph add a bottom
			if (last) {
				last = false;

				/* 				$(this).addClass('fb-box-bottom'); */
			} else {
				$(this).addClass('fb-box-nobottompadding');
			}

			$(this).css('border-color', color);

			//Set the style to the pad
			//$(this).css(style);
		}
	});
}


/*
 * Highlight the words in the pad
 * @param {int} color
 * @param {object} loc
 */
function hightlightWord(color, loc) {
	
	var ace = this.ace;
	
	ace.callWithAce(function (ace){
		//Prevent a loc not found error in browser console
		try {
			ace.ace_performSelectionChange([loc.startX,loc.startY],[loc.endX,loc.endY],true);
			ace.ace_doInsertColors(color);
		} catch (error) {
			
		}
	},'insertColor', true);	
}


/*
 * Make sure at the end nothing is selected
 */
function removeSelection() {
	var ace = this.ace;
	
	ace.callWithAce(function (ace){
		ace.ace_performSelectionChange([0,0],[0,0],true);
	},'insertColor', true);
}


/* 
 * Check which words has to be colored in the pad.
 * @param {object} data
 * @param {array} content
 * @param {function} cb
 */
function colorPad(data, content, cb) {

	var fullText = getText(content);

	var children = content.children('div');

	//Reset the color to black
	resetColor(children);

	var ace = this.ace;
	var timeout = 0;

	//Loop through the info, and check for words to highlight in each paragraph
	for (var i in data.text) {

		for (var j in data.text[i].highlights) {
			var light = data.text[i].highlights[j];

			loc = getLocation(light, fullText[i], function(color, loc) {

				//Color the location if it's found
				if (loc !== null) {
					setTimeout(function() { 
						hightlightWord(color, loc);
					}, timeout);
				}		
	
			});	
		}
	}
	
	//Callback after everything is done, extra 100 timeout to make sure jQuery is done
	setTimeout(function() {
		cb(data, content); 
		removeSelection();
	}, 100);
}


/*
 * Get all the text from the editor and add it to a array
 * @param {object} content
 */
function getText(content) {
	var i = 0;
	var j = 0;
	var fullText = [];
	fullText[i] = [];

	content.children('div').each(function () {
		//Remove HTML tags
		var content = $(this).html().replace(/<\/?[^>]+(>|$)/g, "");

		//If line is empty, new paragraph starts
		if (content === '') {
			i++;
			j++;
			fullText[i] = [];
		} else {

			fullText[i][j] = content;
			j++;
		}
	});

	return fullText;
}


/*
 * Reset all the colors to black
 * @param {object} children
 */
function resetColor(children) {

	//Get number of rows
	var rows = children.size();

	//Set the complete pad to black
	ace.callWithAce(function (ace){
		ace.ace_performSelectionChange([0, 0],[rows, 0],true);
		ace.ace_doInsertColors(0);
		// Note that this is the correct way of doing it, instead of there being
		// a commentId we now flag it as "comment-deleted"
	},'insertColor', true);
}


/*
 * Get the location of a search inside the text
 * @param {string} light
 * @param {array} array: one paragraph of the full text
 * @return {object}
 */
function getLocation(light, array, cb) {

	var search = light.text;

	//Loop through the array for each line
	for(var index in array) {
		//regex to find the word 
		var startY = array[index].search('\s*?(' + search + ')[\\s.,?]');

		//If found
		if (startY > -1) {
			//Get endY, endY is startY + length of the search
			var endY = startY + search.length;
			
			cb(light.color, {startX: index, startY: startY, endX: index, endY: endY});

			return {startX: index, startY: startY, endX: index, endY: endY};
		}
	}
	
	//If search not found
	cb(null);
	return null;
}


/* 
 * Our colors attribute will result in a heaading:h1... :h6 class
 * @param {string} hook
 * @param {object} context
 */
function aceAttribsToClasses(hook, context){
	if(context.key == 'colors'){
		return ['colors:' + context.value ];
	}
}


/* 
 * Here we convert the class colors:h1 into a tag
 * @param {string} name
 * @param {string} context
 * @Copyright to plugin ep_color. 
 */
function aceCreateDomLine(name, context){
	var cls = context.cls;
	var domline = context.domline;
	var colorsType = /(?:^| )colors:([A-Za-z0-9]*)/.exec(cls);

	var tagIndex;
	if (colorsType) tagIndex = _.indexOf(colors, colorsType[1]);


	if (tagIndex !== undefined && tagIndex >= 0){
		//console.log('COLOR');
		//console.log(tagIndex, colorsType[1]);    

		var tag = colors[tagIndex];
		var modifier = {
			extraOpenTags: '<span style="color: ' + tag + ';">',
			extraCloseTags: '</span>',
			cls: cls
		};
		//console.log(cls);
		return [modifier];
	}
	return [];
}


/* 
 * Find out which lines are selected and assign them the colors attribute.
 * Passing a level >= 0 will set a colors on the selected lines, level < 0 
 * will remove it
 * @param {int} level
 * @Copyright to plugin ep_color. 
 */
function doInsertColors(level){
	var rep = this.rep,
		documentAttributeManager = this.documentAttributeManager;
	if (!(rep.selStart && rep.selEnd) || (level >= 0 && colors[level] === undefined))
	{
		return;
	}

	if(level >= 0){
		documentAttributeManager.setAttributesOnRange(rep.selStart, rep.selEnd, [
			['colors', colors[level]]
		]);
	}else{
		documentAttributeManager.setAttributesOnRange(rep.selStart, rep.selEnd, [
			['colors', '']
		]);
	}
}


/* 
 * Once ace is initialized, we set ace_doInsertColors and bind it to the context
 * @param {string} hook
 * @param {object} context
 * @Copyright to plugin ep_color. 
 */
function aceInitialized(hook, context){
	var editorInfo = context.editorInfo;
	editorInfo.ace_doInsertColors = _(doInsertColors).bind(context);
}


//Make sure that exports doesn't give an error
try {
	exports.aceAttribsToClasses = aceAttribsToClasses;
	exports.aceCreateDomLine = aceCreateDomLine;
	exports.aceInitialized = aceInitialized;
} catch (err) {

}

function countWords(data) {

}

function countSentences(data) {


}